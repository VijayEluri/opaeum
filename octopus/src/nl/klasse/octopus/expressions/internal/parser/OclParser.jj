/** This file contains the OCL parser. It produces a parse tree,
 * that needs to be semantically analyzed to be transformed to an
 * official OCL abstract syntax tree.
 */
options {
    STATIC = false;
}

PARSER_BEGIN(OclParser)
package nl.klasse.octopus.expressions.internal.parser.javacc;

import java.util.*;
import java.io.*;
/* for bodyExpression */
//import nl.klasse.octopus.bodyExpression.parsetree.*;
/* end bodyExpression */
import nl.klasse.octopus.expressions.internal.parser.parsetree.context.*;
import nl.klasse.octopus.expressions.internal.parser.parsetree.*;


/* $Id: OclParser.jj,v 1.1 2006/03/01 19:13:33 jwarmer Exp $
 */
public class OclParser {

}

PARSER_END(OclParser)

SKIP:
{
      " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
    | <comment : "--" (~["\n","\r"])* ("\n"|"\r\n")>
    | "/*" : IN_COMMENT
}

<IN_COMMENT> SKIP : 
{
    < ~[] >
}
<IN_COMMENT> SKIP :
{
    "*/" : DEFAULT
}    

/*********************************************************************
 *
 *      Token definitions for OCL expressions.
 *
 *********************************************************************/

TOKEN :
{
  < IF          : "if" >
| < THEN        : "then" >
| < ELSE        : "else" >
| < ENDIF       : "endif" >
| < LET         : "let" >
| < TUPLE       : "Tuple" >
| < IN          : "in" >
| < TRUE        : "true" >
| < FALSE       : "false" >
| < OCLUNDEFINED: "OclUndefined" >
| < AND         : "and" >
| < OR          : "or" >
| < XOR         : "xor">
| < NOT         : "not" >
| < IMPLIES     : "implies" >
| < CONTEXT     : "context" >
| < EXCLAMATION : "!" >
| < DOT         : "."  >
| < RANGE       : ".."  >
| < ARROW       : "->" >
| < DOUBLEDAKJE : "^^" >
| < DAKJE       : "^"  >
| < LESS        : "<"  >
| < GT          : ">"  >
| < LESSEQ      : "<=" >
| < GTEQ        : ">=" >
| < EQUALS      : "="  >
| < NOTEQUALS   : "<>" >
| < PLUS        : "+"  >
| < MINUS       : "-"  >
| < DIVIDE      : "/"  >
| < MULTIPLY    : "*"  >
| < DOUBLECOLON : "::" >
| < UNSPECIFIED : "?"  >
| < COLON       : ":"  >
| < SEMICOLON   : ";"  >
| < BAR         : "|"  >
| < BRACKET_OPEN  : "(" >
| < BRACKET_CLOSE : ")" >
| < CURLY_OPEN    : "{" >
| < CURLY_CLOSE   : "}" >
| < STRAIGHT_OPEN : "[" >
| < STRAIGHT_CLOSE: "]" >
| < AT            : "@" >
| < COMMA         : "," >
/* for bodyExpression */
| < ASSIGN        : ":=" >
| < NEW           : "new" >
/* end bodyExpression */

/********************
 *
 * Keywords for context declarations
 *
 *******************/
| < PACKAGE_START : "package"    >
| < PACKAGE_END   : "endpackage" >
| < INIT          : "init"       >
| < DERIVE        : "derive"     >
| < PRE           : "pre"        >
| < POST          : "post"       >
| < BODY          : "body"       >
| < INV           : "inv"        >
| < DEF           : "def"        >

| < OCLSTRING   :  ["a"-"z", "A"-"Z", "_"] ( ["a"-"z", "A"-"Z", "0"-"9", "_" ] )* >
| < NUMBERLITERAL :  ["0"-"9"] (["0"-"9"])* ( "." ["0"-"9"] (["0"-"9"])* )?
                       ( ("e" | "E") ( "+" | "-" )? ["0"-"9"] (["0"-"9"])* )?     >
| < STRINGLITERAL: // from java 1.1 grammar
      "\'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] (["0"-"7"])? )?
            )
          )
      )*
      "\'"
      >
    

    
    
/**
 * The Notused characters are only there to allow for better error processing.
 */
 | <NOTUSED : ("~" | "`" | "#" | "$" | "%" | "&" | 
					"{" | "}" | "|" | "\\" | 
					"\"" | "?" ) >
}

/*********************************************************************
 *
 * The main starting point for each OclExpression.
 *  The 'source' that starts each OclPropertyCallExp has been removed to avoid left recursion.
 *  As a consequence, OclPropertyCallExp is now postfixed to the OclExpression non-terminal.
 *  In this way each type of OclExpression is allowed to prefix an OclPropertyCallExp.
 *
 *********************************************************************/
ParsedOclExpression OclExpression() : {
    ParsedName            propName = null;
    ParsedPropertyCallExp p        = null;
    ParsedOclExpression   result   = null;
    ParsedLetExp          letExp   = null;
    List                  args     = null;
    boolean               pre      = false;
    boolean               first    = true;
    ParsedOclExpression   last     = null;
    ParsedOclExpression   tmp      = null;
    ParsedLiteral         literal  = null;
    ParsedIfExpression    ifExp    = null;
    ParsedName            unary    = null;
    Token                 head     = null;
    Token                 tail     = null;
    ParsedMessageExp      msg      = null;  // OclMessage
}{
/** WATCH IT: the 'last' variable must always be set to the last parsed expression !!
 */
    (
/** Literals
 *  CS: [C] LiteralExp
 * Lookahead 2 should be enough. This matches "Tuple", "Set", etc.,
 * followed by the curly bracket "{". The other literals are not ambiguous.
 */
      LOOKAHEAD( 2, LiteralExp() ) literal = LiteralExp()
        { result = literal; last = literal; }
/**   The first propertyName can either be a variable or a real property.
 *    This first rule is an exact copy of the DOT rule from OclPropertyCallExp.
 *    CS: [A] PropertyCallExp ; [B] VariableExp ; [C]LiteralExp.[A]EnumLiteralExp ;
 */
      | propName = oclName() [ pre = isMarkedPre() ]
        [ <BRACKET_OPEN> [ args = arguments() ] tail = <BRACKET_CLOSE> ]
        { p = new ParsedPropertyCallExp( propName, pre, null, args);
          p.setPropertyKind(ParsedPropertyCallExp.NO_SOURCE);
          p.startAt( propName.getStart() );
          if( tail == null ){
              p.endAt( propName.getEnd() );
          } else {
              p.setBrackets(true);
              p.endAt(tail);
          }
          result = p;
          last   = result;
        }
/**   Parses Ok, 
 *    CS: n.a.
 */
      | head = <BRACKET_OPEN> tmp = OclExpression() tail = <BRACKET_CLOSE>
        { result = new ParsedBracketExp( tmp);
          result.startAt(head);
          result.endAt  (tail);
          last = result;
        }
/**   CS: [A] PropertyCallExp::ModelCallExp::OperationCallExp[C] ==> special case
 */
      | unary = unaryOperator() result = OclExpression()
        { p = new ParsedPropertyCallExp( unary, pre, null, args);
          p.setPropertyKind(ParsedPropertyCallExp.UNARY_OPERATOR);
          p.setAppliedProperty(result.getAppliedProperty() );
          p.startAt( unary.getStart() );
          p.endAt  ( result.getEnd()  );

          result.setAppliedProperty(p);
          last = result.getLastAppliedProperty();
        }
/** CS: [D] LetExp
 */
      | letExp = LetExpression()
        { result = letExp; last = letExp; }
/** CS: [F] IfExp
 */
      | result = IfExpression()
          { last = result; }
    )
/** The initial start expression is _always_ followed by a property call.
 *  CS: n.a.
 */
	( 
        ( p = PropertyCallExp()
             { last.setAppliedProperty(p); last = p; }
        )
        | // OclMessage 
        (msg = MessageExp()
             { msg.setTarget(result);
               result = msg;
               last   = msg;
             }
        )
    )*
    {
        return result;
    }
}

/** Any parsed name may be prefixed by "<name> ::" many times.
 */
ParsedName oclName() :
{
    Token      head = null;
    Token      tail = null;
    Token      rolename = null;
    ParsedName result;
}{
    head = <OCLSTRING>                     { result = new ParsedName(head); }
    ( <DOUBLECOLON> tail = <OCLSTRING>     { result.addToken( tail ); }
    )*
    [ <STRAIGHT_OPEN> rolename = <OCLSTRING> <STRAIGHT_CLOSE> 
    	{ result.setRolename(rolename);}
    ]
    { result.startAt(head);
      if( tail == null ){
          result.endAt(head);
      } else {
          result.endAt(tail);
      }
      return result; }
}

/** A simple name.
 */
String simpleOclName() :
{
    Token  t;
}{
    t = <OCLSTRING>
    { return t.image; }
}

/** Enumerationms are ParsedPropertyCallExps, because their names are not fixed.
 *  CS: [A] EnumLiteralExp is done in OclExpression
 *      [D] PrimitiveLiteralExp ; [C] TupleLiteralExp ; [B] CollectionLiteralExp
 */
ParsedLiteral LiteralExp() : {
  Token         t;
  ParsedLiteral result = null;
}{
    (   t = <STRINGLITERAL> { result = new ParsedStringLiteral (t.image);
                              result.startAt(t); result.endAt(t); }
      | t = <NUMBERLITERAL> { result = new ParsedNumericLiteral(t.image);
                              result.startAt(t); result.endAt(t); }
      | t = <TRUE>          { result = new ParsedBooleanLiteral(t.image);
                              result.startAt(t); result.endAt(t); }
      | t = <FALSE>         { result = new ParsedBooleanLiteral(t.image);
                              result.startAt(t); result.endAt(t); }
      | t = <OCLUNDEFINED>  { result = new ParsedOclUndefinedLiteral(t.image);
                              result.startAt(t); result.endAt(t); }
      | result = TupleLiteralExp()
      | result = CollectionLiteralExp()

    )
    { return result; }
}

/** A variabledeclaration with optional initialization
 */
ParsedVariableDeclaration VariableDeclaration() :
{
    ParsedName                varName = null;
    ParsedType                type    = null;
    ParsedOclExpression       init    = null;
    ParsedVariableDeclaration result  = null;
}{
    varName = oclName() [ <COLON> type = type() ] [ <EQUALS> init = OclExpression() ]
    { result = new ParsedVariableDeclaration(varName, type, init);
      return result; }
}

/** 
 */
ParsedType type() :
{
    ParsedName typeName = null;
    ParsedType result = null;
}{
    ( LOOKAHEAD( { getToken(1).image.equals("TupleType") } )
        result = tupleType()
      | LOOKAHEAD( collectionType() )
        result = collectionType()
      | typeName = oclName() { result = new ParsedSimpleType(typeName); }
    )
    { return result; }
}

ParsedCollectionType collectionType() : {
    ParsedCollectionType  result      = null;
    ParsedType            elementType = null;
    Token                 head        = null;
    Token                 tail        = null;
}{
    head = <OCLSTRING> <BRACKET_OPEN> elementType = type() tail = <BRACKET_CLOSE>
    {
      result = new ParsedCollectionType(head.image, elementType);
      result.startAt(head);
      result.endAt  (tail);
      return result;
    }
}

/** Parses a tuple type.
 */
ParsedTupleType tupleType() : {
    ParsedTupleType  result   = null;
    List             varDecls = null;
    Token            head     = null;
    Token            tail     = null;
}{
    head = <OCLSTRING> <BRACKET_OPEN> varDecls = variableDeclarationList() tail = <BRACKET_CLOSE>
    {
      result = new ParsedTupleType(varDecls);
      result.startAt(head);
      result.endAt  (tail);
      return result;
    }
}
/** Parses an OclMessage
 */
ParsedMessageExp MessageExp () : {
    ParsedMessageExp          result         = null;
    ParsedName                propName       = null;
    List                      args           = null;
    Token                     start          = null;
    Token                     tail           = null;
}{
    (
        (start = <DAKJE> | start = <DOUBLEDAKJE> )
        propName = oclName()
        <BRACKET_OPEN> [ args = arguments() ] tail = <BRACKET_CLOSE>
    )
    { result = new ParsedMessageExp();
      result.setArguments(args);
      result.setPropertyName(propName) ;
      result.startAt(start);
      result.endAt  (tail );
      if( start.kind == DAKJE ){
      	    result.setMessageKind(ParsedMessageExp.DAKJE);
      } else { // start.kind == DOUBLEDAKJE
        	result.setMessageKind(ParsedMessageExp.DOUBLE_DAKJE);
      }

      return result;
    }

}



/** The PropertyCallExp combines all sub-types into one grammar rule.
 *  This is done because they are very similar to each other and can only be distinguished
 *  by a semantic check with the UML model. We therefore first parse everything as
 *  a ParsedPropertyCallExp and will perform the check in a second pass.
 *  <P> An added bonus is that error messages can be provided on a higher semantic level.
 */
ParsedPropertyCallExp PropertyCallExp() : {
    ParsedPropertyCallExp     result         = null;
    ParsedName                propName       = null;
    ParsedOclExpression       arg            = null;
    ParsedIterators           iterators      = null;
    List                      args           = null;
    boolean                   pre            = false;
    boolean                   isOperator     = false;
    Token                     start          = null;
    Token                     tail           = null;
}{
    (
/*       Infix operators are all predefined.  During the first parse no priority is
 *       used. All operators are applied left-to right. In the second pass the parse
 *       tree needs to be re-arranged by applying the different operator-priorities.
 */
         propName = operator() arg = argument()
           { args = new ArrayList(); args.add(arg); isOperator = true; }

/*       When a collection operation is recognized through an arrow, we need to
 *       do extensive lookahead to check for iterators with their optional parts
 *       and for result variables in an iterate expression.
 *       In the second pass there will be a check whether the actual collection operation
 *       is allowed to have an iterator.
 *       Note that arrow and dot operations and attributes are all combined.
 */
     |
        ((start = <ARROW> | start = <DOT> )
          propName = oclName() [ pre = isMarkedPre() ]
          [
                LOOKAHEAD( <BRACKET_OPEN> VariableDeclaration() <BAR>      |
                           <BRACKET_OPEN> VariableDeclaration() <COMMA> VariableDeclaration() (<BAR> | <SEMICOLON>)   |
                           <BRACKET_OPEN> VariableDeclaration() <SEMICOLON>  )
                <BRACKET_OPEN> iterators = iterateDeclaration() <BAR> arg = argument() tail = <BRACKET_CLOSE>
                    { args = new ArrayList(); args.add(arg); }
                |
                <BRACKET_OPEN> [ args = arguments() ] tail = <BRACKET_CLOSE>
          ]
         )
      )
    { result = new ParsedPropertyCallExp(propName, pre, iterators, args) ;
      if( isOperator ) { result.setPropertyKind(ParsedPropertyCallExp.BINARY_OPERATOR);  }
      else if( start.kind == ARROW      ) { result.setPropertyKind(ParsedPropertyCallExp.ARROW_CALL); }
      else if( start.kind == DOT        ) { result.setPropertyKind(ParsedPropertyCallExp.DOT_CALL); }

      if( isOperator ){
          result.startAt( propName.getStart() );
          result.endAt  ( arg.getEnd() );
      } else {
          result.startAt(start);
          if( tail == null ){
              result.endAt( propName.getEnd());
          } else {
              result.setBrackets(true);
              result.endAt  (  tail );
          }
      }

      return result;
    }

}

/** iterate and iterator variables
 * Any number of iterator variables are allowes, although OCL 2.0 allow at most 2
 * This is to be checked in the semantics check.
 * the same holds for the fact whether the initial value is either disallowed or mandatory.
 */
ParsedIterators iterateDeclaration() : {
  ParsedIterators           result    = null;
  ParsedVariableDeclaration iter      = null;
  ParsedVariableDeclaration resultVar = null;
  List                      iterators = new ArrayList();
}{
    iter = VariableDeclaration()            { iterators.add(iter); }
    ( <COMMA> iter = VariableDeclaration()      { iterators.add(iter); } )*
    [ <SEMICOLON> resultVar = VariableDeclaration() ]
    {
      result = new ParsedIterators(iterators, resultVar);
      return result;
    }
}

/** The predefined infix operators
 */
ParsedName operator() : {
  ParsedName result = null;
}
{
    ( <EQUALS> | <LESS> | <GT> | <GTEQ> | <LESSEQ> | <PLUS> | <MINUS> |
      <MULTIPLY> | <DIVIDE> | <NOTEQUALS> | <AND> | <OR> | <XOR> | <IMPLIES>
    )
    { result = new ParsedName(token);
      result.startAt(token);
      result.endAt(token);
      return result; }
}

/** The pre marker
 */
boolean isMarkedPre() : {}
{
    <AT> <PRE>
    { return true; }
}

/** An argument list, existing of at least one element.
 */
List arguments() :
{
    List                result = new ArrayList();
    ParsedOclExpression arg    = null;
}{
    arg = argument()       { result.add(arg); }
    ( <COMMA> arg = argument() { result.add(arg); } )*
    { return result; }
}

/** Exactly one argument.
 */
ParsedOclExpression argument() : {ParsedOclExpression exp;}
{
    ( exp = OclExpression()
      |
      exp = UnspecifiedValueExp()
    )
    { return exp; }
}

/** Unspecified Value
 */
ParsedUnspecifiedValue UnspecifiedValueExp() : {
    ParsedUnspecifiedValue result   = null;
    ParsedName             typeName = null;
    Token                  t        = null;
}{
    t = <UNSPECIFIED>
    [ <COLON> typeName = oclName() ]
    {
      result = new ParsedUnspecifiedValue(typeName);
      result.startAt(t) ;
      return result;
    }
}

/** The Let expression.
 */
ParsedLetExp LetExpression() : {
    ParsedLetExp              result = null;
    List                      vars   = null;
    ParsedOclExpression       exp    = null;
    Token                     t      = null;
}
{
    t = <LET> vars = variableDeclarationList() <IN> exp = OclExpression()
    {
      result = new ParsedLetExp(vars, exp);
      result.startAt(t);
      return result;
    }
}

/** A list of variable declarations
 */
List variableDeclarationList() : {
  ParsedVariableDeclaration var;
  List                      result = new ArrayList();
}{
    var = VariableDeclaration()       { result.add(var); }
    ( <COMMA> var = VariableDeclaration() { result.add(var); } )*
    { return result; }
}

/** If expression. As in OCL 2.0
 */
ParsedIfExpression IfExpression() : {
    ParsedOclExpression ifExp, elseExp, thenExp;
    Token ifToken, endToken;
    ParsedIfExpression result = null;
}{
    ifToken =  <IF>   ifExp   = OclExpression()
               <THEN> thenExp = OclExpression()
               <ELSE> elseExp = OclExpression()
    endToken = <ENDIF>
    { result = new ParsedIfExpression(ifExp, thenExp, elseExp);
      result.startAt(ifToken);
      result.endAt(endToken);
      return result; }
}

/** Collection literals
 */
ParsedCollectionLiteral CollectionLiteralExp() : {
  Token                   head   = null;
  Token                   tail   = null;
  ParsedCollectionLiteral result = null;
  List                    parts  = null;
}{
     head = <OCLSTRING>  // must be "Sequence" | "Bag" | "Set" | "OrderedSet"
     <CURLY_OPEN> parts = CollectionLiteralParts() tail = <CURLY_CLOSE>
     {
       result = new ParsedCollectionLiteral(head.image, parts);
       result.startAt(head);
       result.endAt  (tail);
       return result; }
}

List CollectionLiteralParts() : {
  ParsedOclExpression part   = null;
  List                result = new ArrayList();
}{
    (
    	[ part = CollectionLiteralPart()       { result.add(part); } ]
    	( <COMMA> part = CollectionLiteralPart() { result.add(part); } )*
    	{
      		return result;
    	}
    )
}

ParsedOclExpression CollectionLiteralPart() : {
    ParsedOclExpression first = null, second = null;
}{
    ( first = OclExpression()
      [ <RANGE> second = OclExpression() ]
    )
    {
      if( second == null ){
        return first;
      } else {
        return new ParsedRange(first, second);
      }
    }
}

ParsedTupleLiteral TupleLiteralExp() : {
  List               varDecls = null;
  ParsedTupleLiteral result   = null;
  Token              head     = null;
  Token              tail     = null;
}{
    head = <TUPLE>
    <CURLY_OPEN> varDecls = variableDeclarationList() tail = <CURLY_CLOSE>
    {
      result = new ParsedTupleLiteral(varDecls);
      result.startAt(head);
      result.endAt  (tail);
      return result;
    }
}

ParsedName unaryOperator() : {
   Token t;
   ParsedName result = null;
}{
    ( t = <NOT> | t = <MINUS> )
    {
      result = new ParsedName(token);
      result.startAt(t);
      result.endAt  (t);
      return result; }
}

/************************************************************
 *
 * Grammar rules for context declarations
 *
 ************************************************************/
 
/** The OCL file containing a number of expressions using the 'context' keyword.
 */
ParsedOclFile oclFile(String filename) : {
    ParsedOclFile result = new ParsedOclFile(filename);
    ParsedName pack = null;
    ParsedOclContext content = null;
}{
    ( [<PACKAGE_START> pack = oclName() ] 
      (content = contextDeclaration()
         {result.addContents(content); }     
       )* [<PACKAGE_END>]
       <EOF>
         { 
         	result.setPackageName(pack);
         	return result;
         }
    )
}
  
/** The OCL constraints using the 'context' keyword.
 *  Doing a lot of lookahead to be able to make the right choice.
 */
ParsedOclContext contextDeclaration() : {
    ParsedOclContext context = null;
}{
    ( 
      LOOKAHEAD( <CONTEXT> oclName() ( <DEF> | <INV> )) 
      context = classContext()
         { 
         	return context;
         }
      | LOOKAHEAD( <CONTEXT> oclName() <BRACKET_OPEN> ) 
        context = operationContext()
		 { 
         	return context;
         }
      | LOOKAHEAD( <CONTEXT> oclName() ( <INIT> | <DERIVE> | <COLON> )) 
      context = attributeContext()
         { 
         	return context;
         }
    )
}

/** 'context' className ...
 */
ParsedOclClassContext classContext() : {
    ParsedName             className = null;
    ParsedOclClassContext  result = null;
    ParsedOclUsage		   exp = null;
}{
    ( <CONTEXT> className = oclName()
      { result = new ParsedOclClassContext(className);	  }  
      (   exp = invInClassContext() {result.addInvariant(exp);}
        | exp = defInClassContext() {result.addDefinition(exp);} 
      )+
	    {   
	     result.startAt(className.getStart());
	     result.endAt(className.getEnd());
	     return result;
	    }
    )
}

ParsedOclUsage invInClassContext() : {
    String name = "";
    ParsedOclExpression parsetree = null;
    ParsedOclUsage result    = null;
    Token      contextType;
}{
    (contextType = <INV> ) [ name = simpleOclName() ] <COLON> 
    parsetree = OclExpression()
    { 
        result = new ParsedOclUsage();
        result.setName(name);
        result.setExpression(parsetree);
        result.setType(contextType);
        result.startAt(contextType);
        return result;
    }
}

ParsedOclUsage defInClassContext() : {
    String 						name = "";
    ParsedOclExpression 		parsetree = null;
    ParsedOclUsage 				result    = null;
  	ParsedVariableDeclaration 	var       = null;
  	ParsedOperDefinition 		oper      = null;
    Token      					contextType, end;
}{
    (contextType = <DEF> ) [ name = simpleOclName() ] <COLON> 
    {
        result = new ParsedOclUsage();
        result.setName(name);
        result.setType(contextType);
        result.startAt(contextType);
	}
    ( LOOKAHEAD( simpleOclName() <BRACKET_OPEN>) oper = operationDefinition() 
    	{
    	    result.setOperation(oper);
        	result.setExpression(oper.getExpression());
//	        result.setType(oper.getStart());
//	        result.endAt(oper.getEnd());
        }
    | var = attributeDefinition() 
    	{
    	    result.setVariable(var);
        	result.setExpression(var.getInitExpression());
	        result.endAt(var.getEnd());
        }
    )
    { 
        return result;
    }
}

ParsedVariableDeclaration attributeDefinition() :
{
    ParsedName                varName = null;
    ParsedType                type    = null;
    ParsedOclExpression       init    = null;
    ParsedVariableDeclaration result  = null;
}{
    varName = oclName() [ <COLON> type = type() ] <EQUALS> init = OclExpression()
    { result = new ParsedVariableDeclaration(varName, type, init);
      return result; }
}

/** A single operation definition inside the 'oper' ...
*/
ParsedOperDefinition operationDefinition() : {
    ParsedOperDefinition result     = null;
    String               name       = null;
    List                 pars       = null;
    ParsedOclExpression  exp        = null;
    Token                start, end = null;
    ParsedType           returnType = null;
}{
    name = simpleOclName() 
    start = <BRACKET_OPEN> [ pars = variableDeclarationList() ] end = <BRACKET_CLOSE>
    [ <COLON> returnType = type() ] <EQUALS> exp = OclExpression()
    {
      result = new ParsedOperDefinition(name, pars, returnType, exp);
      result.startAt(start);
      if( (returnType == null) && (exp == null) ){
          result.endAt(end);
      } else {
      	  result.endAt(end); //TBD: einde van returnType of exp nemen
      }
      return result;
    }
}

/** 'context' className::attributeName ...
 */
ParsedOclAttributeContext attributeContext() : {
    ParsedName              	attributeName = null;
    ParsedOclAttributeContext  	result = null;
    ParsedOclUsage		    	exp = null;
    ParsedType           		type = null;
}{
    ( <CONTEXT> attributeName = oclName()
      { result = new ParsedOclAttributeContext(attributeName); }  
    [ <COLON> type = type() ] //TBD: check whether type is really optional
    ( exp = expressionInAttributeContext() { result.addExpression(exp);} )+
	    {
	     result.startAt(attributeName.getStart());
	     result.endAt(attributeName.getEnd());
	     if ( type != null) {
	     	result.setType(type);
	     }
	     return result;
	    }
    )
}

ParsedOclUsage expressionInAttributeContext() : {
    String 				name 	  = "";
    ParsedOclExpression parsetree = null;
    ParsedOclUsage 		result    = null;
    Token      			contextType, end;
}{
    (contextType = <INIT> | contextType = <DERIVE> ) [ name = simpleOclName() ] end = <COLON> 
    parsetree = OclExpression()
    { 
        result = new ParsedOclUsage();
        result.setName(name);
        result.setExpression(parsetree);
        result.setType(contextType);
        result.startAt(contextType);
        result.endAt(end);
        return result;
    }
}
/** 'context' className.operation ...
 */
ParsedOclOperationContext operationContext() : {
    ParsedName                 	operationName = null;
    ParsedOclOperationContext  	result     	  = null;
    List                   		pars          = null;
    ParsedType             		returnType    = null;
    ParsedOclUsage		   		exp 		  = null;
    Token						end;
}{
    <CONTEXT> operationName = oclName()  
        { result = new ParsedOclOperationContext(operationName); }  
    <BRACKET_OPEN> [ pars = variableDeclarationList() {result.setPars(pars);}] end = <BRACKET_CLOSE>
    [ <COLON>  returnType = type() { result.setReturnType(returnType); end = returnType.getEnd(); }]
    ( exp = expressionInOperationContext() {result.addExpression(exp);} )+
	    {
         result.startAt(operationName.getStart());
         result.endAt(end);
	     return result;
	    }
}

/* before adding bodyExpression */
ParsedOclUsage expressionInOperationContext() : {
    String name = "";
    ParsedOclExpression parsetree = null;
    ParsedOclUsage result    = null;
    Token      contextType, end;
}{
    (contextType = <PRE> | contextType = <POST> | contextType = <BODY>) 
    [ name = simpleOclName() ] end = <COLON> 
    [parsetree = OclExpression()]
    { 
        result = new ParsedOclUsage();
        result.setName(name);
        result.setExpression(parsetree);
        result.setType(contextType);
        result.startAt(contextType);
        result.endAt(end);
        return result;
    }
}
/* */

/* after adding bodyExpression 
ParsedOclUsage expressionInOperationContext() : {
    String name = "";
    ParsedOclExpression parsetree = null;
    ParsedOclUsage result    = null;
    Token      contextType, end;
}{
    ((contextType = <PRE> | contextType = <POST>) 
    [ name = simpleOclName() ] end = <COLON> 
    [parsetree = OclExpression()]
    { 
        result = new ParsedOclUsage();
        result.setName(name);
        result.setExpression(parsetree);
        result.setType(contextType);
        result.startAt(contextType);
        result.endAt(end);
        return result;
    } )
    | ( contextType = <BODY>
    	[ name = simpleOclName() ] end = <COLON> 
    	[parsetree = bodyExpression()]
	    { 
	        result = new ParsedOclUsage();
	        result.setName(name);
	        result.setExpression(parsetree);
	        result.setType(contextType);
	        result.startAt(contextType);
	        result.endAt(end);
	        return result;
	    }
      )
}
 end BodyExpression */

/************************************************************
 *
 * Grammar rules for bodyExpression
 *
 ************************************************************/

/* The classes ParsedAssignExpression and ParsedCreateExpression inherit
from ParsedOcleXpression. This is not the most perfect solution, but it will do 
as long as the parser does not allow bodyExpression anywhere else but in the 
operation context with BODY keyword.
*/
/*
ParsedOclExpression bodyExpression() : {
	ParsedOclExpression result = null;
	ParsedOclExpression lhs    = null;
	ParsedOclExpression rhs    = null;
	ParsedOclExpression first  = null;
	ParsedOclExpression next   = null;
	List                list   = new ArrayList();
}{
	(( lhs = OclExpression() [<ASSIGN> rhs = bodyExpression() ]
	  { if (rhs == null) {
	  		first = lhs; 
		    first.startAt(lhs.getStart());
		    first.endAt(lhs.getEnd());
	  	} else {
	  		first = new ParsedAssignExpression();
	  		((ParsedAssignExpression) first).setLeftHandSide(lhs);
	  		((ParsedAssignExpression) first).setRightHandSide(rhs);
		    first.startAt(lhs.getStart());
		    first.endAt(rhs.getEnd());
	  	} 
	  }	)
	| ( first = createExpression() ) )
	( LOOKAHEAD(2) <SEMICOLON> next = bodyExpression() { list.add(next); } )*
	{ if (list.isEmpty()) {
		result = first;
	  } else {
	  	result = new ParsedSequentialExpression();
  		((ParsedSequentialExpression) result).add(first);
  		((ParsedSequentialExpression) result).addAll(list);
	    result.startAt(first.getStart());
	    result.endAt(next.getEnd());	  	
	  }
	  return result;
	}
} 

ParsedCreateExpression createExpression() : {
	ParsedCreateExpression result = null;
	ParsedType          type   = null;
	Token               t;
}{
	t = <NEW> type = type() 
  	{
  		result = new ParsedCreateExpression();
  		((ParsedCreateExpression) result).setType(type);
	    result.startAt(t);
	    result.endAt(type.getEnd());
  		return result;
  	} 
} 
*/