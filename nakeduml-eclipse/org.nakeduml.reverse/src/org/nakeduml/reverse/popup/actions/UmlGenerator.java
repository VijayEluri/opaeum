package org.nakeduml.reverse.popup.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import net.sf.nakeduml.emf.extraction.EmfExtractionPhase;
import net.sf.nakeduml.emf.reverse.EmfElementCreator;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.uml2.uml.Classifier;
import org.eclipse.uml2.uml.DataType;
import org.eclipse.uml2.uml.Interface;
import org.eclipse.uml2.uml.LiteralUnlimitedNatural;
import org.eclipse.uml2.uml.Model;
import org.eclipse.uml2.uml.Operation;
import org.eclipse.uml2.uml.Package;
import org.eclipse.uml2.uml.Parameter;
import org.eclipse.uml2.uml.ParameterDirectionKind;
import org.eclipse.uml2.uml.Property;
import org.eclipse.uml2.uml.Type;
import org.eclipse.uml2.uml.UMLPackage;

public class UmlGenerator {
	private ClassifierFactory factory;

	public void generateUml(Collection<ITypeBinding> selection, File profileFile) throws Exception {
		// EmfElementCreator.registerPathmaps(URI.createURI(findUml2ResourceJar()));
		EmfElementCreator.registerResourceFactories();
		Package library = null;
		if (profileFile.exists()) {
			String absolutePath = profileFile.getAbsolutePath();
			URI uri = URI.createFileURI(absolutePath);
			ResourceSet RESOURCE_SET = new ResourceSetImpl();
			Resource resource = RESOURCE_SET.getResource(uri, true);
			library =  getRootPackage(resource);
			EcoreUtil.resolveAll(library);
			File mappedTypesFile = new File(absolutePath.substring(0,absolutePath.length()-3) + EmfExtractionPhase.MAPPINGS_EXTENSION);
			factory = new ClassifierFactory(library);
			if (mappedTypesFile.exists()) {
				factory.getMappedTypes().load(new FileInputStream(mappedTypesFile));
			}
			for (ITypeBinding t : selection) {
				Classifier cls = factory.getClassifierFor(t);
				factory.getMappedTypes().put(cls.getQualifiedName(), t.getQualifiedName());
				populateAttributes(library, cls, t);
				populateOperations(library, cls, t);
			}
			library.eResource().save(null);
			factory.getMappedTypes().store(new FileOutputStream(mappedTypesFile), "Generated by NakedUml");
		}
	}


	public Package getRootPackage(Resource resource) {
		EList<EObject> contents = resource.getContents();
		for (EObject eObject : contents) {
			if(eObject instanceof Package){
				return (Package) eObject;
			}
		}
		return null;
	}


	private void populateOperations(Package modelOrProfile, Classifier intfce, ITypeBinding beanInfo) {
		IMethodBinding[] mds = beanInfo.getDeclaredMethods();
		for (IMethodBinding md : mds) {
			if (Modifier.isPublic(md.getModifiers()) && !md.isConstructor() && !hasOperation(modelOrProfile, intfce, md) && !isAccessor(md)) {
				Operation oper = createOperation(intfce, md);
				oper.setIsStatic(Modifier.isStatic(md.getModifiers()));
				ITypeBinding returnType = md.getReturnType();
				if (!returnType.getName().equals("void")) {
					Parameter result = oper.createOwnedParameter("result", factory.getClassifierFor(returnType));
					result.setDirection(ParameterDirectionKind.RETURN_LITERAL);
					if (returnType.isArray() || factory.isCollection(returnType)) {
						result.setUpper(LiteralUnlimitedNatural.UNLIMITED);
					}
				}
				ITypeBinding[] parameterTypes = md.getParameterTypes();
				for (int i = 0; i < parameterTypes.length; i++) {
					if (parameterTypes[0].isArray() || factory.isCollection(parameterTypes[0])) {
						Parameter umlParameter = oper.getOwnedParameters().get(i);
						umlParameter.setUpper(LiteralUnlimitedNatural.UNLIMITED);
						umlParameter.setName("parm" + i);
					}
				}
			}
		}
	}

	private boolean isAccessor(IMethodBinding md) {
		// TODO Auto-generated method stub
		boolean returnsVoid = md.getReturnType() == null || md.getReturnType().getName().equals("void");
		boolean setter = md.getName().startsWith("set") && md.getParameterTypes().length == 1 && returnsVoid;
		boolean getter = md.getName().startsWith("get") && !returnsVoid;
		return setter || getter;
	}

	private boolean hasOperation(Package modelOrProfile, Classifier intfce, IMethodBinding md) {
		for (Operation oper : intfce.getOperations()) {
			List<Parameter> args = new ArrayList<Parameter>();
			for (Parameter parameter : oper.getOwnedParameters()) {
				if (parameter.getDirection() == ParameterDirectionKind.IN_LITERAL
						|| parameter.getDirection() == ParameterDirectionKind.INOUT_LITERAL) {
					args.add(parameter);
				}
			}
			if (oper.getName().equals(md.getName()) && md.getParameterTypes().length == args.size()) {
				boolean paramsMatch = true;
				for (int i = 0; i < md.getParameterTypes().length; i++) {
					Parameter parm = args.get(i);
					if (factory.getClassifierFor(md.getParameterTypes()[i]) != parm.getType()) {
						paramsMatch = false;
						break;
					}
				}
				if (paramsMatch) {
					return true;
				}
			}
		}
		return false;
	}

	private void populateAttributes(Package modelOrProfile, Classifier classifier, ITypeBinding binding) {
		Collection<PropertyDescriptor> fields = PropertyDescriptor.getPropertyDescriptors(binding);
		for (PropertyDescriptor pd : fields) {
			ITypeBinding propertyType = pd.getType();
			Property found = findProperty(pd, classifier.getAttributes());
			if (found == null) {
				Property attr = createAttribute(classifier, pd);
				attr.setIsReadOnly(pd.isReadOnly);
				attr.setIsDerived(pd.isReadOnly);
				if (propertyType.isArray()) {
					attr.setUpper(-1);
				}
			}
		}
	}

	private Property findProperty(PropertyDescriptor pd, EList<Property> attributes) {
		Property found = null;
		for (Property property : attributes) {
			if (property.getName().equalsIgnoreCase(pd.getName())) {
				found = property;
				break;
			}
		}
		return found;
	}

	private Operation createOperation(Classifier cls, IMethodBinding md) {
		Operation oper = null;
		if (cls instanceof Interface) {
			oper = ((Interface) cls).createOwnedOperation(md.getName(), getArgumentNames(md), getArgumentTypes(md));
		} else if (cls instanceof DataType) {
			oper = ((DataType) cls).createOwnedOperation(md.getName(), getArgumentNames(md), getArgumentTypes(md));
		} else if (cls instanceof org.eclipse.uml2.uml.Class) {
			oper = ((org.eclipse.uml2.uml.Class) cls).createOwnedOperation(md.getName(), getArgumentNames(md),
					getArgumentTypes(md));
		}
		return oper;
	}

	private Property createAttribute(Classifier cls, PropertyDescriptor pd) {
		Property attr = null;
		if (cls instanceof Interface) {
			attr = ((Interface) cls).createOwnedAttribute(pd.getName(), factory.getClassifierFor(pd.getType()));
		} else if (cls instanceof org.eclipse.uml2.uml.Class) {
			attr = ((org.eclipse.uml2.uml.Class) cls).createOwnedAttribute(pd.getName(),
					factory.getClassifierFor( pd.getType()));
		} else if (cls instanceof DataType) {
			attr = ((DataType) cls).createOwnedAttribute(pd.getName(), factory.getClassifierFor(pd.getType()));
		}
		return attr;
	}

	private EList<String> getArgumentNames(IMethodBinding md) {
		BasicEList<String> results = new BasicEList<String>();
		for (int i = 0; i < md.getParameterTypes().length; i++) {
			results.add("parm" + i);
		}
		return results;
	}

	private EList<Type> getArgumentTypes(IMethodBinding md) {
		BasicEList<Type> results = new BasicEList<Type>();
		ITypeBinding[] pds = md.getParameterTypes();
		for (ITypeBinding pd : pds) {
			results.add(factory.getClassifierFor(pd));
		}
		return results;
	}

}
