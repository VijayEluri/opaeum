package org.opeum.validation.namegeneration;
import org.opeum.feature.MappingInfo;
import org.opeum.metamodel.activities.INakedActivityNode;
import org.opeum.metamodel.activities.INakedOutputPin;
import org.opeum.metamodel.core.INakedAssociation;
import org.opeum.metamodel.core.INakedComplexStructure;
import org.opeum.metamodel.core.INakedElement;
import org.opeum.metamodel.core.INakedEnumerationLiteral;
import org.opeum.metamodel.core.INakedHelper;
import org.opeum.metamodel.core.INakedInterface;
import org.opeum.metamodel.core.INakedMultiplicityElement;
import org.opeum.metamodel.core.INakedTypedElement;
import org.opeum.metamodel.core.INakedValueSpecification;
import org.opeum.metamodel.name.NameWrapper;
import org.opeum.metamodel.name.SingularNameWrapper;
import org.opeum.metamodel.statemachines.INakedState;

import org.opeum.name.NameConverter;
public abstract class AbstractPersistentNameGenerator extends AbstractNameGenerator {
	protected final String generateQualifiedPersistentName(INakedElement nme) {
		if (nme instanceof INakedState) {
			INakedState state = (INakedState) nme;
			if (state.hasEnclosingState()) {
				return generateQualifiedPersistentName(state.getEnclosingState()) + "/"
						+ state.getMappingInfo().getPersistentName();
			} else {
				String asIs = state.getMappingInfo().getPersistentName().getAsIs();
				return asIs;
			}
		} else if (nme instanceof INakedActivityNode) {
			INakedActivityNode node = (INakedActivityNode) nme;
			if (node.getInStructuredNode() != null) {
				return generateQualifiedPersistentName(node.getInStructuredNode()) + "/"
						+ node.getMappingInfo().getPersistentName();
			} else {
				return node.getMappingInfo().getPersistentName().getAsIs();
			}
		}else{
			MappingInfo mappingInfo2 = nme.getMappingInfo();
			if (nme.getOwnerElement() instanceof INakedElement) {
				INakedElement owner = (INakedElement) nme.getOwnerElement();
				MappingInfo mappingInfo = owner.getMappingInfo();
				NameWrapper persistentName = mappingInfo.getPersistentName();
				return persistentName.getAsIs() + "."
						+ mappingInfo2.getPersistentName().getAsIs();
			} else {
				return mappingInfo2.getPersistentName().getAsIs();
			}
		}
	}
	protected final NameWrapper generateSqlName(INakedElement nme) {

		String generatedName = null;
		INakedValueSpecification existingSqlName = getTaggedValue(nme, "persistentName", "persistenceType");
		if (existingSqlName != null) {
			generatedName = existingSqlName.stringValue();
		} else if (nme instanceof INakedAssociation) {
			// Name is generated by UmlNameGenerator
			INakedAssociation ass = (INakedAssociation) nme;
			generatedName = NameConverter.toUnderscoreStyle(ass.getName());
		} else if (nme instanceof INakedMultiplicityElement) {
			INakedTypedElement tew = (INakedTypedElement) nme;
			String name = tew.getName();
			if(tew instanceof INakedOutputPin){
				name=name+"On" + NameConverter.capitalize(tew.getOwnerElement().getName());//TO ensure uniqueness of name
			}
			//TODO check if this was necessary
			boolean isCmCompatible=true;
			boolean isPersistentInterface = tew.getNakedBaseType() instanceof INakedInterface && !(tew.getNakedBaseType() instanceof INakedHelper);
			if (tew.getNakedBaseType() instanceof INakedComplexStructure || (!isCmCompatible && isPersistentInterface)) {
				// foreign key
				// TODO re-evaluate the _id thing
				generatedName = NameConverter.toUnderscoreStyle(name) + "_id";
			} else {
				generatedName = NameConverter.toUnderscoreStyle(name);
			}
		} else if (nme instanceof INakedEnumerationLiteral) {
			INakedEnumerationLiteral nakedLiteral = ((INakedEnumerationLiteral) nme);
			generatedName = nakedLiteral.getName();
		} else {
			// TODO actions within StructuredACtivityNodes
			generatedName = NameConverter.toUnderscoreStyle(nme.getName());
		}
		return new SingularNameWrapper(generatedName.toLowerCase(), null);
	}
}
