#macro(nameOfTarget $node)
#if($node.actionType && $node.isImplicitJoin())artificial_join_for_${node.mappingInfo.persistentName.withoutId}#else${node.mappingInfo.persistentName.withoutId}#end
#end
#if(!$activity.isProcess())
#set($shouldGenerate=false)
#else
<process-definition xmlns="urn:jbpm.org:jpdl-3.2" name="${activity.ownerElement.mappingInfo.persistentName.withoutId}_${activity.mappingInfo.persistentName.withoutId}">
#foreach($partition in $activity.partitions)
  <swimlane name="${partition.mappingInfo.persistentName.withoutId}">
    <assignment #if(${partition.multiplicity.isSingleObject()})actor-id="#{process.actorIdFor${partition.mappingInfo.javaName.capped}"#else pooled-actors="#{process.actorIdsFor${partition.mappingInfo.javaName.capped}"#end/>
  </swimlane>
#end
#set($shouldGenerate=true)
#if($activity.startNodes.size()==1)
#foreach($node in $activity.startNodes)
  <start-state name="$node.mappingInfo.persistentName">
#set($nodeName="start-state")
#parse("Activity/Transitions.vsf")
#end
#else
  <start-state name="artificial_initial_node">
    <transition name="defaul_transition" to="artificial_initial_fork"/>
  </start-state>
  <fork name="artificial_initial_fork">
#set($nodeName="fork")
#foreach($node in $activity.startNodes)
    <transition to="#nameOfTarget($node)"/>
#end
  </fork>
#end
#foreach($node in $activity.activityNodes)
#if($node.controlNodeType)
#if($node.controlNodeType.isDecisionNode())
  <decision name="${node.mappingInfo.persistentName.withoutId}">
#foreach($edge in ${node.allEffectiveOutgoing})  
    <transition to="${edge.effectiveTarget.mappingInfo.persistentName.withoutId}" >
#if($edge.guard)
        <condition>#{process.${edge.guard.mappingInfo.javaName}}</condition>    
#end    
    </transition>
#end    
  </decision>
#elseif($node.controlNodeType.isActivityFinalNode())
  <end-state name="${node.mappingInfo.persistentName.withoutId}" end-complete-process="true"/>
#elseif ($node.controlNodeType.isFlowFinalNode())
  <end-state name="${node.mappingInfo.persistentName.withoutId}"/>
#elseif($node.controlNodeType.isJoinNode())
#set($nodeName="join")
  <join name="${node.mappingInfo.persistentName.withoutId}">
#parse("Activity/Transitions.vsf")
#elseif($node.controlNodeType.isForkNode())
#set($nodeName="fork")
  <fork name="${node.mappingInfo.persistentName.withoutId}">
#parse("Activity/Transitions.vsf")
#elseif(!$node.controlNodeType.isInitialNode())
#set($nodeName="node")
  <node name="${node.mappingInfo.persistentName.withoutId}">
    <action expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
#parse("Activity/Transitions.vsf") 
#end
#elseif($node.actionType)
#if($node.isImplicitJoin())
  <join name="artificial_join_for_${node.mappingInfo.persistentName.withoutId}">
    <transition to="${node.mappingInfo.persistentName.withoutId}"/>
  </join>
#end
#if($node.requiresUserInteraction())
#set($nodeName="task-node")
  <task-node name="${node.mappingInfo.persistentName.withoutId}" signal="never">
    <event type="node-enter"><action expression="#{process.do${node.mappingInfo.javaName.capped}}"/></event>
    <task name="${node.mappingInfo.persistentName.withoutId}" signalling="false" blocking="true" #if($node.inPartition)swimlane="${node.inPartition.mappingInfo.persistentName.withoutId}">#else>
      <assignment #if(${node.target.multiplicity.isSingleObject()}) actor-id="#{process.actorIdFor${node.mappingInfo.javaName.capped}}" #else pooled-actors="#{process.actorIdsFor${node.mappingInfo.javaName.capped}}" #end />#end  
      <controller>
        <variable name="${node.mappingInfo.javaName}" access="read" mapped-name="taskObject"/>
      </controller>
    </task>
#parse("Activity/Transitions.vsf") 
#elseif($node.actionType.isCallAction())
#if($node.calledElement.isProcess())
<!--TODO assignment-->
  <state name="${node.mappingInfo.persistentName.withoutId}">
    <event type="node-enter"  expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
#set($nodeName="state")
#parse("Activity/Transitions.vsf") 
#else
  <node name="${node.mappingInfo.persistentName.withoutId}">
    <action expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
#set($nodeName="node")
#parse("Activity/Transitions.vsf")
#end  
#elseif($node.actionType.isAcceptTimeEventAction())
##TODO mark the node somehow specifying which event to what for
  <state name="${node.mappingInfo.persistentName.withoutId}" >
    <event type="node-enter"><action expression="#{process.do${node.mappingInfo.javaName.capped}}"/></event>
    <event type="node-leave" ><action expression="#{process.cancel${node.mappingInfo.javaName.capped}}"/></event>
#set($nodeName="state")
#parse("Activity/Transitions.vsf") 
#elseif($node.actionType.isAcceptEventAction())
##TODO mark the node somehow specifying which event to what for
  <state name="${node.mappingInfo.persistentName.withoutId}">
#set($nodeName="state")
#parse("Activity/Transitions.vsf") 
#else
  <node name="${node.mappingInfo.persistentName.withoutId}" >
    <action expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
#set($nodeName="node")
#parse("Activity/Transitions.vsf") 
#end
#elseif(${node.objectNodeType})
#if($node.objectNodeType.isParameterNode())
#if($node.parameter.isReturn() || $node.parameter.isException())
##end the activity and terminate all other flows.
  <end-state name="${node.mappingInfo.persistentName.withoutId}">
    <event type="node-enter"  expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
  </end-state>  
#else
  <node name="${node.mappingInfo.persistentName.withoutId}">
    <action expression="#{process.do${node.mappingInfo.javaName.capped}}"/>
#set($nodeName="node")
#parse("Activity/Transitions.vsf") 
#end  
#else
##for output parameters create end state.
  <node name="${node.mappingInfo.persistentName.withoutId}">
#set($nodeName="node")
#parse("Activity/Transitions.vsf") 
#end
#end
#end
</process-definition>
#end
