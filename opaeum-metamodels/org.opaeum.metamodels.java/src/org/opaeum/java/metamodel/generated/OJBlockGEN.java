/*
 * File generated by Grasland Grammar Generator on Dec 23, 2006 7:26:03 PM
 */
package org.opaeum.java.metamodel.generated;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.opaeum.java.metamodel.OJBlock;
import org.opaeum.java.metamodel.OJElement;
import org.opaeum.java.metamodel.OJField;
import org.opaeum.java.metamodel.OJStatement;
import org.opaeum.java.metamodel.utilities.InvariantError;


/** Class ...
 */
abstract public class OJBlockGEN extends OJStatement {
	private List<OJStatement> f_statements = new ArrayList<OJStatement>();
	private List<OJField> f_locals = new ArrayList<OJField>();
	static protected boolean usesAllInstances = false;
	static protected List<OJBlock> allInstances = new ArrayList<OJBlock>();

	/** Default constructor for OJBlock
	 */
	protected OJBlockGEN() {
		super();
		if ( usesAllInstances ) {
			allInstances.add(((OJBlock)this));
		}
	}
	
	/** Constructor for OJBlockGEN
	 * 
	 * @param name 
	 * @param comment 
	 */
	protected OJBlockGEN(String name, String comment) {
		super();
		super.setName(name);
		super.setComment(comment);
		if ( usesAllInstances ) {
			allInstances.add(((OJBlock)this));
		}
	}

	/** Implements the getter for feature '+ statements : OrderedSet(OJStatement)'
	 */
	public List<OJStatement> getStatements() {
		return f_statements;
	}
	
	/** Implements the setter for feature '+ statements : OrderedSet(OJStatement)'
	 * 
	 * @param element 
	 */
	public void setStatements(List<OJStatement> element) {
		if ( f_statements != element ) {
			f_statements = element;
		}
	}
	
	/** Implements the add element function for feature '+ statements : OrderedSet(OJStatement)'
	 * 
	 * @param element 
	 */
	public void addToStatements(OJStatement element) {
		if ( f_statements.contains(element) ) {
			return;
		}
		f_statements.add(element);
	}
	
	/** Implements the remove element function for feature '+ statements : OrderedSet(OJStatement)'
	 * 
	 * @param element 
	 */
	public void removeFromStatements(OJStatement element) {
		f_statements.remove(element);
	}
	
	/** Implements the addition of a number of elements to feature '+ statements : OrderedSet(OJStatement)'
	 * 
	 * @param newElems 
	 */
	public void addToStatements(Collection<OJStatement> newElems) {
		Iterator it = newElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJStatement ) {
				addToStatements((OJStatement)item);
			}
		}
	}
	
	/** Implements the removal of a number of elements from feature '+ statements : OrderedSet(OJStatement)'
	 * 
	 * @param oldElems 
	 */
	public void removeFromStatements(Collection<OJStatement> oldElems) {
		Iterator it = oldElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJStatement ) {
				removeFromStatements((OJStatement)item);
			}
		}
	}
	
	/** Implements the removal of all elements from feature '+ statements : OrderedSet(OJStatement)'
	 */
	public void removeAllFromStatements() {
		/* make a copy of the collection in order to avoid a ConcurrentModificationException*/
		Iterator it = new ArrayList<OJStatement>(getStatements()).iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJStatement ) {
				removeFromStatements((OJStatement)item);
			}
		}
	}
	
	/** Implements the getter for feature '+ locals : OrderedSet(OJField)'
	 */
	public List<OJField> getLocals() {
		return f_locals;
	}
	
	/** Implements the setter for feature '+ locals : OrderedSet(OJField)'
	 * 
	 * @param element 
	 */
	public void setLocals(List<OJField> element) {
		if ( f_locals != element ) {
			f_locals = element;
		}
	}
	
	/** Implements the add element function for feature '+ locals : OrderedSet(OJField)'
	 * 
	 * @param element 
	 */
	public void addToLocals(OJField element) {
		if ( f_locals.contains(element) ) {
			return;
		}
		f_locals.add(element);
	}
	
	/** Implements the remove element function for feature '+ locals : OrderedSet(OJField)'
	 * 
	 * @param element 
	 */
	public void removeFromLocals(OJField element) {
		f_locals.remove(element);
	}
	
	/** Implements the addition of a number of elements to feature '+ locals : OrderedSet(OJField)'
	 * 
	 * @param newElems 
	 */
	public void addToLocals(Collection<OJField> newElems) {
		Iterator it = newElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJField ) {
				addToLocals((OJField)item);
			}
		}
	}
	
	/** Implements the removal of a number of elements from feature '+ locals : OrderedSet(OJField)'
	 * 
	 * @param oldElems 
	 */
	public void removeFromLocals(Collection<OJField> oldElems) {
		Iterator it = oldElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJField ) {
				removeFromLocals((OJField)item);
			}
		}
	}
	
	/** Implements the removal of all elements from feature '+ locals : OrderedSet(OJField)'
	 */
	public void removeAllFromLocals() {
		/* make a copy of the collection in order to avoid a ConcurrentModificationException*/
		Iterator it = new ArrayList<OJField>(getLocals()).iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJField ) {
				removeFromLocals((OJField)item);
			}
		}
	}
	
	/** Checks all invariants of this object and returns a list of messages about broken invariants
	 */
	public List<InvariantError> checkAllInvariants() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}
	
	/** Implements a check on the multiplicities of all attributes and association ends
	 */
	public List<InvariantError> checkMultiplicities() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}
	
	/** Default toString implementation for OJBlock
	 */
	public String toString() {
		String result = "";
		result = super.toString();
		return result;
	}
	
	/** Returns the default identifier for OJBlock
	 */
	public String getIdString() {
		String result = "";
		result = super.getIdString();
		return result;
	}
	
	/** Implements the OCL allInstances operation
	 */
	static public List allInstances() {
		if ( !usesAllInstances ) {
			throw new RuntimeException("allInstances is not implemented for ((OJBlock)this) class. Set usesAllInstances to true, if you want allInstances() implemented.");
		}
		return allInstances;
	}
	
	/** Returns a copy of this instance. True parts, i.e. associations marked
			'aggregate' or 'composite', and attributes, are copied as well. References to
			other objects, i.e. associations not marked 'aggregate' or 'composite', will not
			be copied. The returned copy will refer to the same objects as the original (this)
			instance.
	 */
	public OJElement getCopy() {
		OJBlock result = new OJBlock();
		this.copyInfoInto(result);
		return result;
	}
	
	/** Copies all attributes and associations of this instance into 'copy'.
			True parts, i.e. associations marked 'aggregate' or 'composite', and attributes, 
			are copied as well. References to other objects, i.e. associations not marked 
			'aggregate' or 'composite', will not be copied. The 'copy' will refer 
			to the same objects as the original (this) instance.
	 * 
	 * @param copy 
	 */
	public void copyInfoInto(OJBlock copy) {
		super.copyInfoInto(copy);
		Iterator statementsIt = new ArrayList<OJStatement>(getStatements()).iterator();
		while ( statementsIt.hasNext() ) {
			OJStatement elem = (OJStatement) statementsIt.next();
			copy.addToStatements(elem);
		}
		Iterator localsIt = new ArrayList<OJField>(getLocals()).iterator();
		while ( localsIt.hasNext() ) {
			OJField elem = (OJField) localsIt.next();
			copy.addToLocals(elem);
		}
	}

}