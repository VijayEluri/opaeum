/*
 * File generated by Grasland Grammar Generator on Dec 23, 2006 7:26:03 PM
 */
package org.opaeum.java.metamodel.generated;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.opaeum.java.metamodel.OJClass;
import org.opaeum.java.metamodel.OJElement;
import org.opaeum.java.metamodel.OJInterface;
import org.opaeum.java.metamodel.OJPackage;
import org.opaeum.java.metamodel.OJPathName;
import org.opaeum.java.metamodel.utilities.InvariantError;


/**
 * Class ...
 */
abstract public class OJPackageGEN extends OJElement {
	private Set<OJClass> f_classes = new HashSet<OJClass>();
	private Set<OJInterface> f_interfaces = new HashSet<OJInterface>();
	private OJPackage f_parent = null;
	private Set<OJPackage> f_subpackages = new HashSet<OJPackage>();
	private OJPathName pn;
	static protected boolean usesAllInstances = false;
	static protected List<OJPackage> allInstances = new ArrayList<OJPackage>();
	public static HashMap<OJPathName,Object> pkgs=new HashMap<OJPathName,Object>();

	/**
	 * Constructor for OJPackageGEN
	 * 
	 * @param name
	 * @param comment
	 */
	protected OJPackageGEN(String name, String comment) {
		super();
		super.setName(name);
		super.setComment(comment);
		if (usesAllInstances) {
			allInstances.add(((OJPackage) this));
		}
	}

	/**
	 * Default constructor for OJPackage
	 */
	protected OJPackageGEN() {
		super();
		if (usesAllInstances) {
			allInstances.add(((OJPackage) this));
		}
	}

	/**
	 * Implements the user defined operation '+ getPathName() : OJPathName'
	 */
	public OJPathName getPathName() {
		return this.getParent().getPathName().append(this.getName());
	}

	/**
	 * Implements the user defined operation '+ findClass( path: OJPathName ) :
	 * OJClass'
	 * 
	 * @param path
	 */
	public OJClass findClass(OJPathName path) {
		return (path.isSingleName() ? this.findLocalClass(path.getLast()) : this.findLocalPackage(path.getFirst())
				.findClass(path.getTail()));
	}

	/**
	 * Implements the user defined operation '- findLocalClass( name: String ) :
	 * OJClass'
	 * 
	 * @param name
	 */
	protected OJClass findLocalClass(String name) {
		return any1(name);
	}

	/**
	 * Implements the user defined operation '+ findPackage( path: OJPathName )
	 * : OJPackage'
	 * 
	 * @param path
	 */
	public OJPackage findPackage(OJPathName path) {
		return (path.isSingleName() ? this.findLocalPackage(path.getLast()) : this.findLocalPackage(path.getFirst()).findPackage(
				path.getTail()));
	}

	/**
	 * Implements the user defined operation '- findLocalPackage( name: String )
	 * : OJPackage'
	 * 
	 * @param name
	 */
	protected OJPackage findLocalPackage(String name) {
		return any2(name);
	}

	/**
	 * Implements the setter for feature '+ classes : Set(OJClass)'
	 * 
	 * @param elements
	 */
	public void setClasses(Set<OJClass> elements) {
		if (this.f_classes != elements) {
			Iterator it = this.f_classes.iterator();
			while (it.hasNext()) {
				OJClass x = (OJClass) it.next();
				x.z_internalRemoveFromMyPackage((OJPackage) ((OJPackage) this));
			}
			this.f_classes = elements;
			if (f_classes != null) {
				it = f_classes.iterator();
				while (it.hasNext()) {
					OJClass x = (OJClass) it.next();
					x.z_internalAddToMyPackage((OJPackage) ((OJPackage) this));
				}
			}
		}
	}

	/**
	 * Implements addition of a single element to feature '+ classes :
	 * Set(OJClass)'
	 * 
	 * @param element
	 */
	public  void addToClasses(OJClass element) {
		if (element == null) {
			return;
		}
		if (this.f_classes.contains(element)) {
			this.f_classes.remove(element);
		}
		if (element.getMyPackage() != null) {
			element.getMyPackage().z_internalRemoveFromClasses(element);
		}
		this.f_classes.add(element);
		element.z_internalAddToMyPackage((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements removal of a single element from feature '+ classes :
	 * Set(OJClass)'
	 * 
	 * @param element
	 */
	public void removeFromClasses(OJClass element) {
		if (element == null) {
			return;
		}
		this.f_classes.remove(element);
		element.z_internalRemoveFromMyPackage((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements the getter for + classes : Set(OJClass)
	 */
	public Set<OJClass> getClasses() {
		if (f_classes != null) {
			return Collections.unmodifiableSet(f_classes);
		} else {
			return null;
		}
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalAddToClasses(OJClass element) {
		this.f_classes.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalRemoveFromClasses(OJClass element) {
		this.f_classes.remove(element);
	}

	/**
	 * Implements the addition of a number of elements to classes
	 * 
	 * @param newElems
	 */
	public void addToClasses(Collection<OJClass> newElems) {
		Iterator it = newElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJClass) {
				this.addToClasses((OJClass) item);
			}
		}
	}

	/**
	 * Implements the removal of a number of elements from classes
	 * 
	 * @param oldElems
	 */
	public void removeFromClasses(Collection<OJClass> oldElems) {
		Iterator it = oldElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJClass) {
				this.removeFromClasses((OJClass) item);
			}
		}
	}

	/**
	 * Implements the removal of all elements from classes
	 */
	public void removeAllFromClasses() {
		/*
		 * make a copy of the collection in order to avoid a
		 * ConcurrentModificationException
		 */
		Iterator it = new HashSet<OJClass>(getClasses()).iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJClass) {
				this.removeFromClasses((OJClass) item);
			}
		}
	}

	/**
	 * Implements the setter for feature '+ interfaces : Set(OJInterface)'
	 * 
	 * @param elements
	 */
	public void setInterfaces(Set<OJInterface> elements) {
		if (this.f_interfaces != elements) {
			Iterator it = this.f_interfaces.iterator();
			while (it.hasNext()) {
				OJInterface x = (OJInterface) it.next();
				x.z_internalRemoveFromMyPackage((OJPackage) ((OJPackage) this));
			}
			this.f_interfaces = elements;
			if (f_interfaces != null) {
				it = f_interfaces.iterator();
				while (it.hasNext()) {
					OJInterface x = (OJInterface) it.next();
					x.z_internalAddToMyPackage((OJPackage) ((OJPackage) this));
				}
			}
		}
	}

	/**
	 * Implements addition of a single element to feature '+ interfaces :
	 * Set(OJInterface)'
	 * 
	 * @param element
	 */
	public void addToInterfaces(OJInterface element) {
		if (element == null) {
			return;
		}
		if (this.f_interfaces.contains(element)) {
			this.f_interfaces.remove(element);
		}
		if (element.getMyPackage() != null) {
			element.getMyPackage().z_internalRemoveFromInterfaces(element);
		}
		this.f_interfaces.add(element);
		element.z_internalAddToMyPackage((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements removal of a single element from feature '+ interfaces :
	 * Set(OJInterface)'
	 * 
	 * @param element
	 */
	public void removeFromInterfaces(OJInterface element) {
		if (element == null) {
			return;
		}
		this.f_interfaces.remove(element);
		element.z_internalRemoveFromMyPackage((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements the getter for + interfaces : Set(OJInterface)
	 */
	public Set<OJInterface> getInterfaces() {
		if (f_interfaces != null) {
			return Collections.unmodifiableSet(f_interfaces);
		} else {
			return null;
		}
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalAddToInterfaces(OJInterface element) {
		this.f_interfaces.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalRemoveFromInterfaces(OJInterface element) {
		this.f_interfaces.remove(element);
	}

	/**
	 * Implements the addition of a number of elements to interfaces
	 * 
	 * @param newElems
	 */
	public void addToInterfaces(Collection<OJInterface> newElems) {
		Iterator it = newElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJInterface) {
				this.addToInterfaces((OJInterface) item);
			}
		}
	}

	/**
	 * Implements the removal of a number of elements from interfaces
	 * 
	 * @param oldElems
	 */
	public void removeFromInterfaces(Collection<OJInterface> oldElems) {
		Iterator it = oldElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJInterface) {
				this.removeFromInterfaces((OJInterface) item);
			}
		}
	}

	/**
	 * Implements the removal of all elements from interfaces
	 */
	public void removeAllFromInterfaces() {
		/*
		 * make a copy of the collection in order to avoid a
		 * ConcurrentModificationException
		 */
		Iterator it = new HashSet<OJInterface>(getInterfaces()).iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJInterface) {
				this.removeFromInterfaces((OJInterface) item);
			}
		}
	}

	/**
	 * Implements the setter of association end parent
	 * 
	 * @param element
	 */
	public void setParent(OJPackage element) {
		if (this.f_parent != element) {
			if (this.f_parent != null) {
				this.f_parent.z_internalRemoveFromSubpackages((OJPackage) ((OJPackage) this));
			}
			this.f_parent = element;
			if (element != null) {
				element.z_internalAddToSubpackages((OJPackage) ((OJPackage) this));
				pkgs.put(this.pn=getPathName(), Object.class);
			}
		}
	}
	@Override
	public void finalize(){
		super.finalize();
		pkgs.remove(pn);
	}
	

	/**
	 * Implements the getter for parent
	 */
	public OJPackage getParent() {
		return f_parent;
	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link
	 * for + parent : OJPackage when a single element is added to it.
	 * 
	 * @param element
	 */
	public void z_internalAddToParent(OJPackage element) {
		this.f_parent = element;
		pkgs.put(this.pn=getPathName(), Object.class);

	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link
	 * for + parent : OJPackage when a single element is removed to it.
	 * 
	 * @param element
	 */
	public void z_internalRemoveFromParent(OJPackage element) {
		this.f_parent = null;
	}

	/**
	 * Implements the setter for feature '+ subpackages : Set(OJPackage)'
	 * 
	 * @param elements
	 */
	public void setSubpackages(Set<OJPackage> elements) {
		if (this.f_subpackages != elements) {
			Iterator it = this.f_subpackages.iterator();
			while (it.hasNext()) {
				OJPackage x = (OJPackage) it.next();
				x.z_internalRemoveFromParent((OJPackage) ((OJPackage) this));
			}
			this.f_subpackages = elements;
			if (f_subpackages != null) {
				it = f_subpackages.iterator();
				while (it.hasNext()) {
					OJPackage x = (OJPackage) it.next();
					x.z_internalAddToParent((OJPackage) ((OJPackage) this));
				}
			}
		}
	}

	/**
	 * Implements addition of a single element to feature '+ subpackages :
	 * Set(OJPackage)'
	 * 
	 * @param element
	 */
	public synchronized void addToSubpackages(OJPackage element) {
		if (element == null) {
			return;
		}
		if (this.f_subpackages.contains(element)) {
			this.f_subpackages.remove(element);
		}
		if (element.getParent() != null) {
			element.getParent().z_internalRemoveFromSubpackages(element);
		}
		this.f_subpackages.add(element);
		element.z_internalAddToParent((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements removal of a single element from feature '+ subpackages :
	 * Set(OJPackage)'
	 * 
	 * @param element
	 */
	public void removeFromSubpackages(OJPackage element) {
		if (element == null) {
			return;
		}
		this.f_subpackages.remove(element);
		element.z_internalRemoveFromParent((OJPackage) ((OJPackage) this));
	}

	/**
	 * Implements the getter for + subpackages : Set(OJPackage)
	 */
	public Set<OJPackage> getSubpackages() {
		if (f_subpackages != null) {
			return Collections.unmodifiableSet(f_subpackages);
		} else {
			return null;
		}
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalAddToSubpackages(OJPackage element) {
		for (OJPackage pkg : f_subpackages) {
			if (pkg.getName().equals(element.getName()))
				throw new RuntimeException();
		}
		this.f_subpackages.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element
	 */
	public void z_internalRemoveFromSubpackages(OJPackage element) {
		this.f_subpackages.remove(element);
	}

	/**
	 * Implements the addition of a number of elements to subpackages
	 * 
	 * @param newElems
	 */
	public void addToSubpackages(Collection<OJPackage> newElems) {
		Iterator it = newElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJPackage) {
				this.addToSubpackages((OJPackage) item);
			}
		}
	}

	/**
	 * Implements the removal of a number of elements from subpackages
	 * 
	 * @param oldElems
	 */
	public void removeFromSubpackages(Collection<OJPackage> oldElems) {
		Iterator it = oldElems.iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJPackage) {
				this.removeFromSubpackages((OJPackage) item);
			}
		}
	}

	/**
	 * Implements the removal of all elements from subpackages
	 */
	public void removeAllFromSubpackages() {
		/*
		 * make a copy of the collection in order to avoid a
		 * ConcurrentModificationException
		 */
		Iterator it = new HashSet<OJPackage>(getSubpackages()).iterator();
		while ((it.hasNext())) {
			Object item = it.next();
			if (item instanceof OJPackage) {
				this.removeFromSubpackages((OJPackage) item);
			}
		}
	}

	/**
	 * Implements ->any( c : OJClass | c.name = name )
	 * 
	 * @param name
	 */
	private OJClass any1(String name) {
		OJClass result = null;
		Iterator it = this.getClasses().iterator();
		while (it.hasNext()) {
			OJClass c = (OJClass) it.next();
			if (c.getName().equals(name)) {
				return c;
			}
		}
		return result;
	}

	/**
	 * Implements ->any( c : OJPackage | c.name = name )
	 * 
	 * @param name
	 */
	private OJPackage any2(String name) {
		OJPackage result = null;
		Iterator it = this.getSubpackages().iterator();
		while (it.hasNext()) {
			OJPackage c = (OJPackage) it.next();
			if (c.getName().equals(name)) {
				return c;
			}
		}
		return result;
	}

	/**
	 * Checks all invariants of this object and returns a list of messages about
	 * broken invariants
	 */
	public List<InvariantError> checkAllInvariants() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}

	/**
	 * Implements a check on the multiplicities of all attributes and
	 * association ends
	 */
	public List<InvariantError> checkMultiplicities() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		if (getParent() == null) {
			String message = "Mandatory feature 'parent' in object '";
			message = message + this.getIdString();
			message = message + "' of type '" + this.getClass().getName() + "' has no value.";
			result.add(new InvariantError(((OJPackage) this), message));
		}
		return result;
	}

	/**
	 * Default toString implementation for OJPackage
	 */
	public String toString() {
		String result = "";
		result = super.toString();
		return result;
	}

	/**
	 * Returns the default identifier for OJPackage
	 */
	public String getIdString() {
		String result = "";
		result = super.getIdString();
		return result;
	}

	/**
	 * Implements the OCL allInstances operation
	 */
	static public List allInstances() {
		if (!usesAllInstances) {
			throw new RuntimeException(
					"allInstances is not implemented for ((OJPackage)this) class. Set usesAllInstances to true, if you want allInstances() implemented.");
		}
		return allInstances;
	}

	/**
	 * Returns a copy of this instance. True parts, i.e. associations marked
	 * 'aggregate' or 'composite', and attributes, are copied as well.
	 * References to other objects, i.e. associations not marked 'aggregate' or
	 * 'composite', will not be copied. The returned copy will refer to the same
	 * objects as the original (this) instance.
	 */
	public OJElement getCopy() {
		OJPackage result = new OJPackage();
		this.copyInfoInto(result);
		return result;
	}

	/**
	 * Copies all attributes and associations of this instance into 'copy'. True
	 * parts, i.e. associations marked 'aggregate' or 'composite', and
	 * attributes, are copied as well. References to other objects, i.e.
	 * associations not marked 'aggregate' or 'composite', will not be copied.
	 * The 'copy' will refer to the same objects as the original (this)
	 * instance.
	 * 
	 * @param copy
	 */
	public void copyInfoInto(OJPackage copy) {
		super.copyInfoInto(copy);
		Iterator classesIt = new ArrayList<OJClass>(getClasses()).iterator();
		while (classesIt.hasNext()) {
			OJClass elem = (OJClass) classesIt.next();
			copy.addToClasses(elem);
		}
		Iterator interfacesIt = new ArrayList<OJInterface>(getInterfaces()).iterator();
		while (interfacesIt.hasNext()) {
			OJInterface elem = (OJInterface) interfacesIt.next();
			copy.addToInterfaces(elem);
		}
		if (getParent() != null) {
			copy.setParent(getParent());
		}
		Iterator subpackagesIt = new ArrayList<OJPackage>(getSubpackages()).iterator();
		while (subpackagesIt.hasNext()) {
			OJPackage elem = (OJPackage) subpackagesIt.next();
			copy.addToSubpackages(elem);
		}
	}
}