/*
 * File generated by Grasland Grammar Generator on Dec 23, 2006 7:26:03 PM
 */
package org.opaeum.java.metamodel.generated;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.opaeum.java.metamodel.OJElement;
import org.opaeum.java.metamodel.OJPathName;
import org.opaeum.java.metamodel.utilities.InvariantError;
import org.opaeum.java.metamodel.utilities.Stdlib;


/** Class ...
 */
abstract public class OJPathNameGEN extends OJElement {
	private List<String> f_names = new ArrayList<String>();
	static protected OJPathName f_vOID = null;
	private List<OJPathName> f_elementTypes = new ArrayList<OJPathName>();
	static protected boolean usesAllInstances = false;
	static protected List<OJPathName> allInstances = new ArrayList<OJPathName>();

	/** Constructor for OJPathNameGEN
	 * 
	 * @param name 
	 * @param comment 
	 */
	protected OJPathNameGEN(String name, String comment) {
		super();
		super.setName(name);
		super.setComment(comment);
		if ( usesAllInstances ) {
			allInstances.add(((OJPathName)this));
		}
	}
	
	/** Default constructor for OJPathName
	 */
	protected OJPathNameGEN() {
		super();
		if ( usesAllInstances ) {
			allInstances.add(((OJPathName)this));
		}
	}

	/** Implements the user defined operation '+ append( name: String ) : OJPathName'
	 * 
	 * @param name 
	 */
	public OJPathName append(String name) {
		OJPathName result = null;
		return result;
	}
	
	/** Implements the user defined operation '+ prepend( name: String ) : OJPathName'
	 * 
	 * @param name 
	 */
	public OJPathName prepend(String name) {
		OJPathName result = null;
		return result;
	}
	
	/** Implements the user defined operation '+ getFirst() : String'
	 */
	public String getFirst() {
		return (this.getNames().size() > 0 ?((String)this.getNames().get( 0 )) : "");
	}
	
	/** Implements the user defined operation '+ getLast() : String'
	 */
	public String getLast() {
		return (this.getNames().size() > 0 ?((String)this.getNames().get( this.getNames().size()-1 )) : "");
	}
	
	/** Implements the user defined operation '+ getTail() : OJPathName'
	 */
	public OJPathName getTail() {
		OJPathName result = null;
		return result;
	}
	
	/** Implements the user defined operation '+ getHead() : OJPathName'
	 */
	public OJPathName getHead() {
		OJPathName result = null;
		return result;
	}
	
	/** Implements the user defined operation '+ isSingleName() : Boolean'
	 */
	public boolean isSingleName() {
		return (this.getNames().size() == 1);
	}
	
	/** Implements the user defined operation '+ equals( other: OJPathName ) : Boolean'
	 * 
	 * @param other 
	 */
	public boolean equals(OJPathName other) {
		return (Stdlib.sequenceEquals(this.getNames(), other.getNames()));
	}
	
	/** Implements the getter for feature '+ names : Sequence(String)'
	 */
	public List<String> getNames() {
		return f_names;
	}
	
	/** Implements the setter for feature '+ names : Sequence(String)'
	 * 
	 * @param element 
	 */
	public void setNames(List<String> element) {
		if ( f_names != element ) {
			f_names = element;
		}
	}
	
	/** Implements the add element function for feature '+ names : Sequence(String)'
	 * 
	 * @param element 
	 */
	public void addToNames(String element) {
		f_names.add(element);
	}
	
	/** Implements the remove element function for feature '+ names : Sequence(String)'
	 * 
	 * @param element 
	 */
	public void removeFromNames(String element) {
		f_names.remove(element);
	}
	
	/** Implements the addition of a number of elements to feature '+ names : Sequence(String)'
	 * 
	 * @param newElems 
	 */
	public void addToNames(Collection<String> newElems) {
		Iterator it = newElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof String ) {
				addToNames((String)item);
			}
		}
	}
	
	/** Implements the removal of a number of elements from feature '+ names : Sequence(String)'
	 * 
	 * @param oldElems 
	 */
	public void removeFromNames(Collection<String> oldElems) {
		Iterator it = oldElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof String ) {
				removeFromNames((String)item);
			}
		}
	}
	
	/** Implements the removal of all elements from feature '+ names : Sequence(String)'
	 */
	public void removeAllFromNames() {
		/* make a copy of the collection in order to avoid a ConcurrentModificationException*/
		Iterator it = new ArrayList<String>(getNames()).iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof String ) {
				removeFromNames((String)item);
			}
		}
	}
	
	/** Implements the getter for feature '+ $ VOID : OJPathName'
	 */
	static public OJPathName getVOID() {
		return f_vOID;
	}
	
	/** Implements the setter for feature '+ $ VOID : OJPathName'
	 * 
	 * @param element 
	 */
	static public void setVOID(OJPathName element) {
		if ( f_vOID != element ) {
			f_vOID = element;
		}
	}
	
	/** Implements the getter for feature '+ elementTypes : OrderedSet(OJPathName)'
	 */
	public List<OJPathName> getElementTypes() {
		return f_elementTypes;
	}
	
	/** Implements the setter for feature '+ elementTypes : OrderedSet(OJPathName)'
	 * 
	 * @param element 
	 */
	public void setElementTypes(List<OJPathName> element) {
		if ( f_elementTypes != element ) {
			f_elementTypes = element;
		}
	}
	
	/** Implements the add element function for feature '+ elementTypes : OrderedSet(OJPathName)'
	 * 
	 * @param element 
	 */
	public void addToElementTypes(OJPathName element) {
//		if ( f_elementTypes.contains(element) ) {
//			return;
//		}
		f_elementTypes.add(element);
	}
	
	/** Implements the remove element function for feature '+ elementTypes : OrderedSet(OJPathName)'
	 * 
	 * @param element 
	 */
	public void removeFromElementTypes(OJPathName element) {
		f_elementTypes.remove(element);
	}
	
	/** Implements the addition of a number of elements to feature '+ elementTypes : OrderedSet(OJPathName)'
	 * 
	 * @param newElems 
	 */
	public void addToElementTypes(Collection<OJPathName> newElems) {
		Iterator it = newElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJPathName ) {
				addToElementTypes((OJPathName)item);
			}
		}
	}
	
	/** Implements the removal of a number of elements from feature '+ elementTypes : OrderedSet(OJPathName)'
	 * 
	 * @param oldElems 
	 */
	public void removeFromElementTypes(Collection<OJPathName> oldElems) {
		Iterator it = oldElems.iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJPathName ) {
				removeFromElementTypes((OJPathName)item);
			}
		}
	}
	
	/** Implements the removal of all elements from feature '+ elementTypes : OrderedSet(OJPathName)'
	 */
	public void removeAllFromElementTypes() {
		/* make a copy of the collection in order to avoid a ConcurrentModificationException*/
		Iterator it = new ArrayList<OJPathName>(getElementTypes()).iterator();
		while ( (it.hasNext()) ) {
			Object item = it.next();
			if ( item instanceof OJPathName ) {
				removeFromElementTypes((OJPathName)item);
			}
		}
	}
	
	/** Checks all invariants of this object and returns a list of messages about broken invariants
	 */
	public List<InvariantError> checkAllInvariants() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}
	
	/** Implements a check on the multiplicities of all attributes and association ends
	 */
	public List<InvariantError> checkMultiplicities() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}
	
	/** Default toString implementation for OJPathName
	 */
	public String toString() {
		String result = "";
		result = super.toString();
		if ( this.getNames() != null ) {
			result = result + " names:" + this.getNames();
		}
		return result;
	}
	
	/** Returns the default identifier for OJPathName
	 */
	public String getIdString() {
		String result = "";
		result = super.getIdString();
		return result;
	}
	
	/** Implements the OCL allInstances operation
	 */
	static public List allInstances() {
		if ( !usesAllInstances ) {
			throw new RuntimeException("allInstances is not implemented for ((OJPathName)this) class. Set usesAllInstances to true, if you want allInstances() implemented.");
		}
		return allInstances;
	}
	
	/** Returns a copy of this instance. True parts, i.e. associations marked
			'aggregate' or 'composite', and attributes, are copied as well. References to
			other objects, i.e. associations not marked 'aggregate' or 'composite', will not
			be copied. The returned copy will refer to the same objects as the original (this)
			instance.
	 */
	public OJElement getCopy() {
		OJPathName result = new OJPathName();
		this.copyInfoInto(result);
		return result;
	}
	
	/** Copies all attributes and associations of this instance into 'copy'.
			True parts, i.e. associations marked 'aggregate' or 'composite', and attributes, 
			are copied as well. References to other objects, i.e. associations not marked 
			'aggregate' or 'composite', will not be copied. The 'copy' will refer 
			to the same objects as the original (this) instance.
	 * 
	 * @param copy 
	 */
	public void copyInfoInto(OJPathName copy) {
		super.copyInfoInto(copy);
		Iterator namesIt = new ArrayList<String>(getNames()).iterator();
		while ( namesIt.hasNext() ) {
			String elem = (String) namesIt.next();
			copy.addToNames(elem);
		}
		Iterator elementTypesIt = new ArrayList<OJPathName>(getElementTypes()).iterator();
		while ( elementTypesIt.hasNext() ) {
			OJPathName elem = (OJPathName) elementTypesIt.next();
			copy.addToElementTypes(elem);
		}
	}

}